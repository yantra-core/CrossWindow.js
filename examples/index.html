<!DOCTYPE html>
<html>


<head>
  <title>CrossWindow.js Demo</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://yantra.gg/labyrinthos/browser/vendor/jquery.min.js"></script>
  <meta name="description" content="A JavaScript procedural generator for Mazes, Terrains, and Biomes">
  <script src="./mantra.js"></script>
  <script src="./crosswindow.js"></script>
  <script src="./crosswindow.debugger.js"></script>

  <style>


    .main {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    button {
      position: absolute;
      padding: 0.1em;
      font-size: 1.5em;
      height: 3em;
      /* Responsive font size */
      cursor: pointer;
      z-index: 9999;
      transition: background-color 0.2s;
      /* Smooth transition for hover effect */
    }

    button:hover {
      background-color: rgba(255, 255, 255, 0.2);
      /* Change background on hover */
    }

    #openWindowButtons {
      position: absolute;
      bottom: 100px;
      right: 130px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      padding: 0.5em;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }



    @media (max-width: 600px) {
      button {
        padding: 0.5em;
        font-size: 0.75em;
        /* Smaller font size for small screens */
      }
    }
  </style>
</head>

<body>

  <div id="openWindowButtons">
    <button>Open Window</button>
  </div>
  <script>
    let crosswindow = new CW.CrossWindow();
    let crossWindowDebugger = new CWDEBUG.CrossWindowDebugger(crosswindow);

    document.querySelectorAll('#openWindowButtons button').forEach(button => {
      button.addEventListener('click', function () {
        const direction = this.getAttribute('data-direction');
        const windowWidth = window.innerWidth;
        const windowHeight = window.outerHeight - 75;
        const offsetX = window.screenX; // Current window's distance from the left edge of the screen
        const offsetY = window.screenY; // Current window's distance from the top edge of the screen
        let buffer = 10; // Define a buffer distance for the new window
        let top = offsetY, left = offsetX;

        //console.log('top', top, 'left', left);

        // Open new window with calculated top and left positions
        crosswindow.open('index.html?win', {
          width: windowWidth,
          height: windowHeight,
          top: top /*- window.outerHeight*/,
          left: left + window.outerWidth,
        }, true);
      });
    });

    document.addEventListener('DOMContentLoaded', (event) => {
      let game = new MANTRA.Game({
        graphics: ['css'], // array enum, 'babylon', 'css', 'three'
        // Plugins at construction
        plugins: ['Player', 'Draggable', 'Hexapod', 'Tower', 'RBush', 'Key', 'Block', 'Collectable', 'Teleporter', 'Gamepad', 'Bullet'],
        width: 400,
        height: 300,
        gameRoot: 'http://192.168.1.80:7777'
      });
      window.game = game;
      game.config.entityEmitsViewportExitEvent = true;

      let remoteEntMap = {};

      crosswindow.on('message', function (event) {
        let data = event.data || event.payload; // fix this
        let action = event.action;

        if (event.payload && event.payload.action) {
          // TODO: remove this old API
          action = event.payload.action;
          data = event.payload;
        }

        if (action === 'inputs') {
          // don't process own inputs
          // console.log("eventeventevent", event)
          // check to see if current window has focus, if so return
          if (document.hasFocus()) {
            return;
          }
          let controls = data.controls;
          //console.log("WIINNNPUTS", controls);
          for (let control in controls) {
            let value = controls[control];
            // console.log('control', control, 'value', value);
            if (value === true) {
              //game.rules.emit(control);
              // dispatch a new KeyboardEvent to browser dom
              // this will trigger the game's keyboard event listener
              // and the game will handle the input
              document.dispatchEvent(new KeyboardEvent('keydown', { 'code': 'Key' + control }));
            } else {
              //console.log("DOWN")
              document.dispatchEvent(new KeyboardEvent('keyup', { 'code': 'Key' + control }));
            }
          }

          return;
        }

        if (action === 'intersecting') {
          handleIntersection(event);
          return;
        }
        //  game.flashMessage(action);
        let source = event.sourceWindowId;
        remoteEntMap[source] = remoteEntMap[source] || {};

        //console.log('Message received from another window:', event, source, data);
        //console.log('my window', crosswindow.windowId);
        //console.log("the source", source)

        let entityData = data;
        // Remark: The other conditional case is for intersecting and overlapping ents
        // that would exist in both windows at once ( with one being hidden behind the other )
        if (true || typeof remoteEntMap[source][entityData.id] === 'undefined') {
          // this local node has never seen this ent from the remote node
          // so we need to create it
          // focus this window
          window.focus();
          let position = entityData.position;
          let builder = game.make();
          // Entity Types as Builder Class
          let type = entityData.type;
          type = type.toLowerCase();
          type = type.charAt(0).toUpperCase() + type.slice(1);
          //console.log('type', type, builder);
          builder[type]();
          // builder.isSensor(false);
          //builder.size(64)
          builder.health(entityData.health);
          builder.velocity(entityData.velocity.x, entityData.velocity.y);
          builder.rotation(entityData.rotation);
          
          // Remark: Here is a special case where we need to send the full
          // item over the cross window instead of ent reference
          // since the relational data is from another mantra instance ( and no longer valid )
          // re-inflate all the items manually
          let itemIds = [];
          entityData.items.forEach(function(ent){
            ent.owner = game.currentPlayerId
            let id = game.createEntity(ent);
            itemIds.push(id);
          });
          builder.items(itemIds);
          
          builder.x(position.x).y(position.y);
          builder.z(1); // for now
          // console.log('creating local ent', builder.config);

          if (builder.config.type === "PLAYER") {
            // remove all other players ( for now )
            game.removeEntitiesByType('PLAYER');
          }


          if (builder.config.type === 'HEXAPOD') {

            // see if there is a current player on mantra
            let currentPlayer = game.getEntity(game.currentPlayerId);
            // console.log('CCCCC', currentPlayer)



              if (currentPlayer) {
                game.systems.hexapod.setTarget(currentPlayer.position);

                builder.meta({
                  target: {
                    x: currentPlayer.position.x,
                    y: currentPlayer.position.y
                  }
                });

              } else {
                builder.meta({
                  target: {
                    x: entityData.meta.target.x,
                    y: entityData.meta.target.y
                  }
                });

              }

          }

          //console.log("CREATING ENT", builder.config)

          let ent = builder.createEntity();
          if (ent.type === "PLAYER") {
            game.setPlayerId(ent.id);
            let globalPosition = {
              x: ent.position.x + window.screenX,
              y: ent.position.y + window.screenY
            };
            //console.log('saving global', globalPosition);
            localStorage.setItem('mantra-currentPlayer', JSON.stringify(globalPosition));

            // update target
            if (game.systems.hexapod) {
              game.systems.hexapod.setTarget(globalPosition);
            }

          }

          remoteEntMap[source][entityData.id] = ent.id; // now we have a mapping of remoteId to localId
          //console.log('stored ref', ent.id, remoteEntMap[source][entityData.id])
        } else {
          // the local node has seen this ent from the remote node
          // so we need to update it
          // get the local ent
          let localId = remoteEntMap[source][entityData.id];
          let localEnt = game.getEntity(localId);
          if (localEnt) {
            // update the local ent
            localEnt.type = entityData.type;
            localEnt.position = entityData.position;
            localEnt.rotation = entityData.rotation;
            localEnt.velocity = entityData.velocity;
            localEnt.health = entityData.health;
            localEnt.position.x += 10;
            localEnt.position.y += 10;
            localEnt.meta = entityData.meta || {};
            localEnt.items = entityData.items || [];

            let windowWidth = window.innerWidth;
            let windowHeight = window.innerHeight;
            localEnt.position.z = 1;

            let windowMeta = crosswindow.getWindowMetadata(source);
            //console.log('windowMeta', windowMeta)
            // TODO: apply proper zoom and offset based on current and target window position diff and zoom
            //localEnt.position.x = localEnt.position.x + entityData.screenPosition.x / game.data.camera.currentZoom - windowMeta.position.x;
            //localEnt.position.y = localEnt.position.y + entityData.screenPosition.y / game.data.camera.currentZoom - windowMeta.position.y;

            //localEnt.screenPosition = entityData.screenPosition;
            //console.log('updating local ent', localEnt.id, entityData, localEnt);
            game.updateEntity(localEnt.id, localEnt);
          } else {
            //console.log('tried to match remove to local ent not found', localId);
            console.log(source, crosswindow.windowId, remoteEntMap);
          }
        }

      });

      // this will render the current window box *once* immediately on load
      crosswindow.emit('windowChanged', {
        windowId: crosswindow.windowId,
        metadata: {
          position: {
            x: window.screenX,
            y: window.screenY
          },
          size: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        }
      });

      // listens for local game keyboard events and broadcasts them too all crosswindows
      // this may not be needed if we assumed that window.focus() was always working
      // and that user didn't click on wrong window by accident
      game.on('keyboard::handleInputs', (data) => {

        if (!document.hasFocus()) {
          return;

        }

        if (data && data.controls) {
          // let currentInputs = data.controls; // TODO: gamepad merge scope
          let currentInputs = data.controls || {};
          if (Object.keys(currentInputs).length) {
            // console.log('keyboard::handleInputs', data)
            if (crosswindow && crosswindow.postMessage) {
              crosswindow.postMessage('any', {
                action: 'inputs',
                //entityId: entityId,
                controls: data.controls,
                //sequenceNumber: sequenceNumber
              });
            }

          }

        }
      });

      // listen to the Mantra event for when entity leaves the viewport
      game.on('entity::exited::viewport', function (entity) {
        let actualItems = [];
        if (entity.items) {
          entity.items.forEach(item => {
          let ent = game.getEntity(item);
          console.log('exit item ent', ent)
          if (ent) {
            actualItems.push({
            position: ent.position,
            size: ent.size,
            type: ent.type,
            collectable: ent.collectable
          });
          }
        });

        }

        console.log('sending out actual items', actualItems)
        let entityData = {
          id: entity.id,
          type: entity.type,
          health: entity.health,
          position: entity.position,
          rotation: entity.rotation,
          velocity: entity.velocity,
          rotation: entity.rotation,
          meta: entity.meta,
          items: actualItems,
          screenPosition: entity.screenPosition
        };

        console.log('entity::exited::viewport', entityData);

        let bestWindow = crosswindow.getBestWindow(entityData);
        // console.log('found bestWindow', bestWindow, crosswindow.windowId);
        if (bestWindow) {

          //let entryPosition = bestWindow.entryPosition(direction, entityData);
          //console.log('entryPositionentryPositionentryPosition')
          if (bestWindow.windowId === crosswindow.windowId) {
            // if the best window is the current window, then we don't need to send a message
            // we can just remove the entity
            console.log("game.setPosition", bestWindow, entityData.entryPosition)
            game.setPosition(entity.id, bestWindow.entryPosition);
            //game.removeEntity(entity.id);
            return;
          } else {
            console.log('removing', entity.id)
            game.removeEntity(entity.id);
            bestWindow.postMessage(entityData);
            //console.log('Message sent to best window:', entityData, bestWindow);

          }

        } else {
          console.log('no bestWindow', bestWindow)
        }

        // console.log('bestWindow', bestWindow)

      });


      game.use('Bullet'); // plugins at runtime
      // TODO: have boomerang work cross window ( needs dynamic target tracker like Hexapod )
      // game.use('Boomerang'); // plugins at runtime

      game.start(function () {

        // game.make().Block().Draggable().color('blue').size(32).createEntity();
        // Boomerang action should be left click for demo
        game.config.mouseActionButton = 'LEFT';
        game.config.mouseMovementButton = 'RIGHT';
        //game.reset();

        game.setBackground('#000000');

        let currentWindows = crosswindow.getWindows();

        // check if 'win' exists as query string variable, if no, so player
        // if not, create player
        let isSubWindow = window.location.search.includes('win');
        if (!isSubWindow) {
          let currentPlayer = game.make().Player().createEntity();
          // set currentPlayer in localStorage so Hexapods can track it cross window
          let globalPosition = {
            x: currentPlayer.position.x - window.screenX,
            y: currentPlayer.position.y - window.screenY
          };
          console.log('saving global', globalPosition);
          localStorage.setItem('mantra-currentPlayer', JSON.stringify(globalPosition));
          // update target
          if (game.systems.hexapod) {
            game.systems.hexapod.setTarget(globalPosition);
          }
          /*
          for (let i = 0; i < 1; i++) {
          let randomRadial = game.radialSpread(0, 0, 100, 1, i);
            setTimeout(function(){
              game.make().Key({
              position: randomRadial
            }).body(true).createEntity();
          }, 30000)
                  }

          */

        } else {

          let savedPlayer = JSON.parse(localStorage.getItem('mantra-currentPlayer'));

          // alert(localStorage.getItem('mantra-currentPlayer'));

          let target = null;
          if (savedPlayer) {
            target = savedPlayer;
          }
          game.make().Hexapod({
            target: savedPlayer
          }).repeat(6).createEntity();
        }

      });


    });


    function handleIntersection(event) {
      console.log('intersecting', event);

      let source = event.sourceWindowId;
      let target = event.targetWindowId;
      let area = event.intersectionArea;

      let windowWidth = window.innerWidth;
      let windowHeight = window.innerHeight;
      let worldPosition = {
        x: area.position.x / game.data.camera.currentZoom,
        y: area.position.y / game.data.camera.currentZoom
      };
      worldPosition.x = worldPosition.x - (windowWidth / 2);
      worldPosition.y = worldPosition.y - (windowHeight / 2);

      let worldArea = {
        width: area.size.width / game.data.camera.currentZoom,
        height: area.size.height / game.data.camera.currentZoom
      };

      if (game.systems.rbush) {
        // Directly use the calculated worldPosition and worldArea for the query
        var query = {
          minX: worldPosition.x,
          minY: worldPosition.y,
          maxX: worldPosition.x + worldArea.width,
          maxY: worldPosition.y + worldArea.height
        };

        //console.log('performing query in world coordinates', query);
        let ents = game.systems.rbush.search(query);
        if (ents.length) {
          console.log('found ents in world coordinates', ents);
        }

        if (ents.length) {
          // iterate through all the ents, remove them and add them to the other window
          for (let i = 0; i < ents.length; i++) {
            let entity = game.getEntity(ents[i]);
            entity.position.z = 1;
            entity.screenPosition = {
              x: entity.position.x * game.data.camera.currentZoom + (windowWidth / 2),
              y: entity.position.y * game.data.camera.currentZoom + (windowHeight / 2),
              z: 1
            };
            console.log(ents[i], entity)
            let entityData = {
              id: entity.id,
              type: entity.type,
              position: entity.position,
              rotation: entity.rotation,
              velocity: entity.velocity,
              rotation: entity.rotation,
              body: true,
              items: entity.items,
              screenPosition: entity.screenPosition
            };

            console.log('entityData', entityData);

            crosswindow.sendMessage(source, entityData);
            console.log('Message sent to parent window:', source, entityData);
            console.log('my current window', crosswindow.windowId);
            console.log("the target was", target)
            // instead of just a remove / create here
            // should we instead have an updateEntity method?
            // such that the items never get scooped up, just duplicated?
            // should work, but we do need to keep a local mapping table here
            // of remote entId to localId so we can update by remoteId
            // ( ent ids wont match cross mantra instance )
            // for now, until proper instection update is working 
            // game.removeEntity(entityData.id);
          }
        }

      }
    }


  </script>

</body>

</html>
<!DOCTYPE html>
<html>


<head>
  <title>CrossWindow.js Demo</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://yantra.gg/labyrinthos/browser/vendor/jquery.min.js"></script>
  <meta name="description" content="A JavaScript procedural generator for Mazes, Terrains, and Biomes">
  <script src="./mantra.js"></script>
  <script src="./crosswindow.js"></script>


  <style>
    #windowsContainer {
      /* background-color: aqua; */
      z-index: 8888;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* opacity: 0.3; */
    }

    .main {
      position: relative;
      /* Makes .main the reference for absolutely positioned children */
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    button {
      position: absolute;
      /* Position buttons absolutely within .main */
      padding: 20px;
      font-size: 24px;
      cursor: pointer;
      z-index: 9999;
    }

    button[data-direction="N"] {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    button[data-direction="NE"] {
      top: 0;
      right: 0;
    }

    button[data-direction="E"] {
      top: 50%;
      right: 0;
      transform: translateY(-50%);
    }

    button[data-direction="SE"] {
      bottom: 0;
      right: 0;
    }

    button[data-direction="S"] {
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    button[data-direction="SW"] {
      bottom: 0;
      left: 0;
    }

    button[data-direction="W"] {
      top: 50%;
      left: 0;
      transform: translateY(-50%);
    }

    button[data-direction="NW"] {
      top: 0;
      left: 0;
    }

    /* adds response query for width and button size */
    @media (max-width: 600px) {
      button {
        padding: 10px;
        font-size: 12px;
      }
    }
  </style>
</head>

<body>
  <div id="directionButtons">

    <button data-direction="NW">↖ NW</button>
    <button data-direction="N">↑ N</button>
    <button data-direction="NE">↗ NE</button>
    <button data-direction="E">→ E</button>
    <button data-direction="SE">↘ SE</button>
    <button data-direction="S">↓ S</button>
    <button data-direction="SW">↙ SW</button>
    <button data-direction="W">← W</button>
  </div>
  <script>
    let crosswindow = new CW.CrossWindow();

    document.querySelectorAll('#directionButtons button').forEach(button => {
      button.addEventListener('click', function () {
        const direction = this.getAttribute('data-direction');
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const offsetX = window.screenX; // Current window's distance from the left edge of the screen
        const offsetY = window.screenY; // Current window's distance from the top edge of the screen
        let buffer = 10; // Define a buffer distance for the new window
        let top = offsetY, left = offsetX;

        switch (direction) {
          case 'N':  // WORKING
            top = offsetY - windowHeight - buffer;
            left = offsetX - windowWidth;
            break;
          case 'NE': // WORKING
            top = offsetY - windowHeight - buffer;
            left = offsetX;
            break;
          case 'E': // WORKING
            top = offsetY;
            left = offsetX + buffer + windowWidth / 2; // Align E window with the right edge of the current window
            break;
          case 'SE':
            top = offsetY + windowHeight + buffer;
            left = offsetX; // Align SE window with the E edge of the current window
            break;
          case 'S': // WORKING
            top = offsetY + windowHeight + buffer;
            left = offsetX - windowWidth; // Align S window with the bottom edge, offset to the left
            break;
          case 'SW':
            top = offsetY + windowHeight + buffer;
            left = offsetX - windowWidth * 2 - buffer; // Align SW window to the left of the S window
            break;
          case 'W': // WORKING
            top = offsetY;
            left = offsetX - buffer - windowWidth; // Align E window with the right edge of the current window
            break;
          case 'NW':
            top = offsetY - windowHeight - buffer;
            left = offsetX - windowWidth * 2 - buffer; // Align NW window above and to the left, similar to W and N
            break;
        }

        console.log('top', top, 'left', left);

        // Open new window with calculated top and left positions
        crosswindow.open('index.html?win', {
          width: windowWidth,
          height: windowHeight,
          top: top,
          left: left,
        }, true);
      });
    });


    document.addEventListener('DOMContentLoaded', (event) => {

      let game = new MANTRA.Game({
        graphics: ['css'], // array enum, 'babylon', 'css', 'three'
        // Plugins at construction
        plugins: ['Player', 'Draggable', 'Hexapod', 'Tower', 'RBush', 'Key', 'Block', 'Collectable', 'Teleporter', 'Gamepad', 'Bullet'],
        width: 400,
        height: 300,
        gameRoot: 'http://192.168.1.80:7777'
      });
      window.game = game;
      game.config.entityEmitsViewportExitEvent = true;

      let remoteEntMap = {};

      // TODO: create simple HTML + CSS boxes that track the position of the remote windows
      // relative to the current window
      // we should update or create the boxes on windowChanged event
      // we will have access to currentWindowMetadata
      /*
        currentWindowMetadata.windowId
        currentWindowMetadata.metadata
        currentWindowMetadata.metadata.position
        currentWindowMetadata.metadata.size

      */

      crosswindow.on('windowClosed', function (currentWindowMetadata) {
        // remove the window preview if exists
        let windowBox = document.getElementById('windowBox_' + currentWindowMetadata.windowId);
        if (windowBox) {
          windowBox.remove();
        }
      });

      // TODO: move this debugger window code into library
      crosswindow.on('windowChanged', function (currentWindowMetadata) {
        // console.log('windowChanged', currentWindowMetadata);


        if (currentWindowMetadata.windowId === crosswindow.windowId) {
          // do not create a box for the current window
          // return;
        }

        crosswindow.updateOrCreateDebugContainer(currentWindowMetadata);

      });

      crosswindow.pollWindows();

      crosswindow.on('message', function (event) {
        let data = event.data || event.payload; // fix this
        let action = event.action;

        if (event.payload && event.payload.action) {
          // TODO: remove this old API
          action = event.payload.action;
          data = event.payload;
        }

        if (action === 'inputs') {
          // don't process own inputs
          // console.log("eventeventevent", event)
          // check to see if current window has focus, if so return
          if (document.hasFocus()) {
            return;
          }
          let controls = data.controls;
          //console.log("WIINNNPUTS", controls);
          for (let control in controls) {
            let value = controls[control];
            // console.log('control', control, 'value', value);
            if (value === true) {
              //game.rules.emit(control);
              // dispatch a new KeyboardEvent to browser dom
              // this will trigger the game's keyboard event listener
              // and the game will handle the input
              document.dispatchEvent(new KeyboardEvent('keydown', { 'code': 'Key' + control }));
            } else {
              //console.log("DOWN")
              document.dispatchEvent(new KeyboardEvent('keyup', { 'code': 'Key' + control }));
            }
          }

          return;
        }

        if (action === 'intersecting') {
          handleIntersection(event);
          return;
        }
        //  game.flashMessage(action);
        let source = event.sourceWindowId;
        remoteEntMap[source] = remoteEntMap[source] || {};

        //console.log('Message received from another window:', event, source, data);
        //console.log('my window', crosswindow.windowId);
        //console.log("the source", source)

        let entityData = data;
        // TODO: make sure to GC this later on ent removal
        if (typeof remoteEntMap[source][entityData.id] === 'undefined') {
          // this local node has never seen this ent from the remote node
          // so we need to create it
          // focus this window
          window.focus();
          let position = entityData.position;
          let builder = game.make();
          // Entity Types as Builder Class
          let type = entityData.type;
          type = type.toLowerCase();
          type = type.charAt(0).toUpperCase() + type.slice(1);
          //console.log('type', type, builder);
          builder[type]();
          // builder.isSensor(false);
          //builder.size(64)
          builder.velocity(entityData.velocity.x, entityData.velocity.y);
          builder.rotation(entityData.rotation);
          builder.x(position.x).y(position.y);
          builder.z(1); // for now
          // console.log('creating local ent', builder.config);

          if (builder.config.type === "PLAYER") {
            // remove all other players ( for now )
            game.removeEntitiesByType('PLAYER');
          }
          console.log("CREATING ENT", builder.config)

          let ent = builder.createEntity();
          if (ent.type === "PLAYER") {
            game.setPlayerId(ent.id);
          }
          remoteEntMap[source][entityData.id] = ent.id; // now we have a mapping of remoteId to localId
          //console.log('stored ref', ent.id, remoteEntMap[source][entityData.id])
        } else {
          // the local node has seen this ent from the remote node
          // so we need to update it
          // get the local ent
          let localId = remoteEntMap[source][entityData.id];
          let localEnt = game.getEntity(localId);
          if (localEnt) {
            // update the local ent
            localEnt.position = entityData.position;
            localEnt.rotation = entityData.rotation;
            localEnt.velocity = entityData.velocity;
            localEnt.position.x += 10;
            localEnt.position.y += 10;

            let windowWidth = window.innerWidth;
            let windowHeight = window.innerHeight;
            localEnt.position.z = 1;

            let windowMeta = crosswindow.getWindowMetadata(source);
            //console.log('windowMeta', windowMeta)
            // TODO: apply proper zoom and offset based on current and target window position diff and zoom
            //localEnt.position.x = localEnt.position.x + entityData.screenPosition.x / game.data.camera.currentZoom - windowMeta.position.x;
            //localEnt.position.y = localEnt.position.y + entityData.screenPosition.y / game.data.camera.currentZoom - windowMeta.position.y;

            //localEnt.screenPosition = entityData.screenPosition;
            //console.log('updating local ent', localEnt.id, entityData, localEnt);
            game.updateEntity(localEnt.id, localEnt);
          } else {
            //console.log('tried to match remove to local ent not found', localId);
            console.log(source, crosswindow.windowId, remoteEntMap);
          }
        }

      });

      // this will render the current window box *once* immediately on load
      crosswindow.emit('windowChanged', {
        windowId: crosswindow.windowId,
        metadata: {
          position: {
            x: window.screenX,
            y: window.screenY
          },
          size: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        }
      });

      // listens for local game keyboard events and broadcasts them too all crosswindows
      // this may not be needed if we assumed that window.focus() was always working
      // and that user didn't click on wrong window by accident
      game.on('keyboard::handleInputs', (data) => {

        if (!document.hasFocus()) {
          return;

        }

        if (data && data.controls) {
          // let currentInputs = data.controls; // TODO: gamepad merge scope
          let currentInputs = data.controls || {};
          if (Object.keys(currentInputs).length) {
            // console.log('keyboard::handleInputs', data)
            if (crosswindow && crosswindow.postMessage) {
              crosswindow.postMessage('any', {
                action: 'inputs',
                //entityId: entityId,
                controls: data.controls,
                //sequenceNumber: sequenceNumber
              });
            }

          }

        }
      });

      // listen to the Mantra event for when entity leaves the viewport
      game.on('entity::exited::viewport', function (entity) {
        let entityData = {
          id: entity.id,
          type: entity.type,
          position: entity.position,
          rotation: entity.rotation,
          velocity: entity.velocity,
          rotation: entity.rotation,
          screenPosition: entity.screenPosition
        };

        console.log('entity::exited::viewport', entityData);

        let bestWindow = crosswindow.getBestWindow(entityData);
        // console.log('found bestWindow', bestWindow, crosswindow.windowId);
        if (bestWindow) {

          //let entryPosition = bestWindow.entryPosition(direction, entityData);
          //console.log('entryPositionentryPositionentryPosition')
          if (bestWindow.windowId === crosswindow.windowId) {
            // if the best window is the current window, then we don't need to send a message
            // we can just remove the entity
            console.log("game.setPosition", bestWindow, entityData.entryPosition)
            game.setPosition(entity.id, bestWindow.entryPosition);
            //game.removeEntity(entity.id);
            return;
          } else {
            console.log('removing', entity.id)
            game.removeEntity(entity.id);
            bestWindow.postMessage(entityData);
            //console.log('Message sent to best window:', entityData, bestWindow);

          }

        } else {
          console.log('no bestWindow', bestWindow)
        }

        // console.log('bestWindow', bestWindow)

      });


      // Plugins at runtime
      game.use('Bullet'); // plugins at runtime
      game.start(function () {

        // game.make().Block().Draggable().color('blue').size(32).createEntity();
        // Boomerang action should be left click for demo
        game.config.mouseActionButton = 'LEFT';
        game.config.mouseMovementButton = 'RIGHT';
        //game.reset();

        game.setBackground('#000000');

        let currentWindows = crosswindow.getWindows();

        // check if 'win' exists as query string variable, if no, so player
        // if not, create player
        let isSubWindow = window.location.search.includes('win');
        if (!isSubWindow) {
          game.make().Player().createEntity();
        }

        // alert(Object.keys(currentWindows).length)
        if (Object.keys(currentWindows).length <= 1) {
        } else {
          //         game.make().Hexapod().repeat(11).createEntity();
          //game.make().Tower().color('red').angle(270).position(-32, 0).createEntity();
          //game.make().Tower().color('orange').angle(0).position(0, -32).createEntity();

          //game.make().Tower().color('yellow').angle(180).position(0, 32).createEntity();
          //game.make().Tower().color('purple').angle(90).position(32, 0).createEntity();


        }

        /*
        for (let i = 0; i < 10; i++) {
          let randomRadial = game.radialSpread(0, 0, 100, 10, i);
          game.make().Key({
            position: randomRadial
          }).body(true).createEntity();
        }
        */

      });
    });


    function handleIntersection(event) {
      console.log('intersecting', event);
      /*
game.flashMessage({
message: JSON.stringify(data.payload, true, 2),
duration: 5000,
type: 'info'
});
*/

      let source = event.sourceWindowId;
      let target = event.targetWindowId;
      let area = event.intersectionArea;
      // game.flashMessage(JSON.stringify(area));
      //console.log('intersection')
      //console.log('area.position', area.position);

      let windowWidth = window.innerWidth;
      let windowHeight = window.innerHeight;
      let worldPosition = {
        x: area.position.x / game.data.camera.currentZoom,
        y: area.position.y / game.data.camera.currentZoom
      };
      worldPosition.x = worldPosition.x - (windowWidth / 2);
      worldPosition.y = worldPosition.y - (windowHeight / 2);

      let worldArea = {
        width: area.size.width / game.data.camera.currentZoom,
        height: area.size.height / game.data.camera.currentZoom
      };

      // needs to be uncommecnt when camera not 0,0 ( moved )
      // we can ignore the camera position for now ( testing )
      //worldPosition.x = worldPosition.x + game.data.camera.position.x;
      //worldPosition.y = worldPosition.y + game.data.camera.position.y;

      //console.log('area.size', area.size);
      //console.log('worldPosition', worldPosition);
      //console.log('worldArea', worldArea);

      // area.position
      // area.size
      if (game.systems.rbush) {
        // Directly use the calculated worldPosition and worldArea for the query
        var query = {
          minX: worldPosition.x,
          minY: worldPosition.y,
          maxX: worldPosition.x + worldArea.width,
          maxY: worldPosition.y + worldArea.height
        };

        //console.log('performing query in world coordinates', query);
        let ents = game.systems.rbush.search(query);
        if (ents.length) {
          console.log('found ents in world coordinates', ents);
        }

        if (ents.length) {
          // iterate through all the ents, remove them and add them to the other window
          for (let i = 0; i < ents.length; i++) {
            let entity = game.getEntity(ents[i]);
            entity.position.z = 1;
            entity.screenPosition = {
              x: entity.position.x * game.data.camera.currentZoom + (windowWidth / 2),
              y: entity.position.y * game.data.camera.currentZoom + (windowHeight / 2),
              z: 1
            };
            console.log(ents[i], entity)
            let entityData = {
              id: entity.id,
              type: entity.type,
              position: entity.position,
              rotation: entity.rotation,
              velocity: entity.velocity,
              rotation: entity.rotation,
              body: true,
              screenPosition: entity.screenPosition
            };

            console.log('entityData', entityData);

            crosswindow.sendMessage(source, entityData);
            console.log('Message sent to parent window:', source, entityData);
            console.log('my current window', crosswindow.windowId);
            console.log("the target was", target)
            // instead of just a remove / create here
            // should we instead have an updateEntity method?
            // such that the items never get scooped up, just duplicated?
            // should work, but we do need to keep a local mapping table here
            // of remote entId to localId so we can update by remoteId
            // ( ent ids wont match cross mantra instance )
            // for now, until proper instection update is working 
            // game.removeEntity(entityData.id);
          }
        }

      }
    }


  </script>
  <!-- Container where remote window boxes will be displayed -->
  <div id="windowsContainer" style="position: absolute;"></div>

</body>

</html>